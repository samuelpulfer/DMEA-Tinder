<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>DMEA Tinder</title>
  <link rel="stylesheet" href="css/all.min.css">
  <style>
    *, *:after, *:before {
      box-sizing: border-box;
    }

    body {
      font-family: "Open Sans", sans-serif;
      padding: 0;
      margin: 0;
      background-color: rgb(245, 247, 250);
    }

    nav {
      background-color: #872557;
      position: fixed;
      bottom: 0;
      width: 100%;

    }

    nav ul {
      list-style: none;
      display: flex;
      padding: 0;
      margin: 0;
    }

    nav ul li {
      display: inline-block;
      width: 50%;
      text-align: center;
    }

    nav li a {
      padding: 10px 0;
      display: block;
      color: #fff;
      text-decoration: none;
    }


    .card:after {
      content: '';
      display: block;
      position: absolute;
      right: 50%;
      margin-right: -67px;
      top: 78px;
      width: 134px;
      padding: 29px 0;
      text-align: center;
      font-size: 66px;
      border: 5px solid;
      border-radius: 100%;
      opacity: 0;
      font-weight: bold;
      background: #ffffffe3;
      font-family: "Font Awesome 5 Pro";
    }

    .card a {
      text-decoration: none;
      font-size: 14px;
      color: #2980b9;
    }

    .card.up:after {
      content: '\f005';
      color: #2980b9;
      opacity: 1;
    }

    .card.right:after {
      opacity: 1;
      content: '\f004';
      color: #2ecc71;
      line-height: 1;
    }

    .card.left:after {

      line-height: 1;
      opacity: 1;
      content: '\f7a9';
      color: #c0392b;
    }

    #board {
      width: 100%;
      height: 100vh;
      position: relative;
      overflow: hidden;
      margin: auto;
    }


    .card h2 {
      margin-top: 0;
      font-size: 18px;
    }

    .card .description {
      font-size: 12px;
      text-overflow: ellipsis;
      max-height: 52%;
      overflow: hidden;
    }

    .card {
      overflow: hidden;
      width: 80vw;
      height: 60vh;
      position: absolute;
      top: 50vh;
      left: 50%;
      border-radius: 1%;
      box-shadow: 0px 4px 4px 0px rgba(0, 0, 0, 0.1);
      background-color: white;
      transform: translateX(-50%) translateY(-50%) scale(1) rotate(4deg);
      padding: 10px;
      word-break: break-word;
      max-width: 324px;
      max-height: 500px;
    }

    .logo {
      position: fixed;
      left: 50%;
      max-width: 300px;
      width: 300px;
      display: block;
      margin-left: -150px;
      margin-top: 30px;
    }

    nav ul li.active {
      background: #0000004f;
    }

    .card.full {
      width: 100vw;
      height: 90vh;
      max-width: 400px;
      max-height: 600px;
      top: 47vh;
      z-index: 100;
    }

    .card.full .description {
      max-height: 100%;
    }

  </style>
</head>
<body>

<img src="dmea.svg" alt="DMEA" class="logo">

<div id="board"></div>
<nav>
  <ul>
    <li><a href="#"><i class="fas fa-list"></i> <br>Liste</a></li>
    <li class="active"><a href="#"><i class="fas fa-heart"></i> <br>Ausw√§hlen</a></li>
  </ul>
</nav>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment-with-locales.min.js"></script>

<script>


  /* LikeCarousel (c) 2019 Simone P.M. github.com/simonepm - Licensed MIT */

  class Carousel {

    constructor(element) {

      this.i = 0;

      this.board = element

      // add first two cards programmatically
      this.push()
      this.push()
      this.push()

      // handle gestures
      this.handle()
    }

    handle() {

      // list all cards
      this.cards = this.board.querySelectorAll('.card')

      // get top card
      this.topCard = this.cards[this.cards.length - 1]

      // get next card
      this.nextCard = this.cards[this.cards.length - 2]

      // if at least one card is present
      if (this.cards.length > 0) {

        // set default top card position and scale
        this.topCard.style.transform =
                'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(1)'

        // destroy previous Hammer instance, if present
        if (this.hammer) this.hammer.destroy()

        // listen for tap and pan gestures on top card
        this.hammer = new Hammer(this.topCard)
        this.hammer.add(new Hammer.Tap())
        this.hammer.add(new Hammer.Pan({
          position: Hammer.position_ALL, threshold: 0
        }))

        // pass events data to custom callbacks
        this.hammer.on('tap', (e) => {
          this.onTap(e)
        })
        this.hammer.on('pan', (e) => {
          this.onPan(e)
        })

      }

    }

    onTap(e) {
      // get finger position on top card
      let propX = (e.center.x - e.target.getBoundingClientRect().left) / e.target.clientWidth

      // get degree of Y rotation (+/-15 degrees)
      let rotateY = 15 * (propX < 0.05 ? -1 : 1)

      // change the transition property
      this.topCard.style.transition = 'transform 100ms ease-out'

      // rotate
      this.topCard.style.transform =
              'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(' + rotateY + 'deg) scale(1)'


      // wait transition end
      setTimeout(() => {
        // reset transform properties
        this.topCard.style.transform =
                'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(1)'
        this.topCard.classList.add("full")
      }, 100)

    }

    onPan(e) {

      if (!this.isPanning) {

        this.isPanning = true

        // remove transition properties
        this.topCard.style.transition = null
        if (this.nextCard) this.nextCard.style.transition = null

        // get top card coordinates in pixels
        let style = window.getComputedStyle(this.topCard)
        let mx = style.transform.match(/^matrix\((.+)\)$/)
        this.startPosX = mx ? parseFloat(mx[1].split(', ')[4]) : 0
        this.startPosY = mx ? parseFloat(mx[1].split(', ')[5]) : 0

        // get top card bounds
        let bounds = this.topCard.getBoundingClientRect()

        // get finger position on top card, top (1) or bottom (-1)
        this.isDraggingFrom =
                (e.center.y - bounds.top) > this.topCard.clientHeight / 2 ? -1 : 1

      }

      // calculate new coordinates
      let posX = e.deltaX + this.startPosX
      let posY = e.deltaY + this.startPosY

      // get ratio between swiped pixels and the axes
      let propX = e.deltaX / this.board.clientWidth
      let propY = e.deltaY / this.board.clientHeight

      // get swipe direction, left (-1) or right (1)
      let dirX = e.deltaX < 0 ? -1 : 1

      // calculate rotation, between 0 and +/- 45 deg
      let deg = this.isDraggingFrom * dirX * Math.abs(propX) * 45

      // calculate scale ratio, between 95 and 100 %
      let scale = (95 + (5 * Math.abs(propX))) / 100

      // move top card
      this.topCard.style.transform =
              'translateX(' + posX + 'px) translateY(' + posY + 'px) rotate(' + deg + 'deg) rotateY(0deg) scale(1)'

      // scale next card
      if (this.nextCard) this.nextCard.style.transform =
              'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(' + scale + ')'


      // check threshold
      if (propX > 0.2) {
        this.topCard.classList.remove("left")
        this.topCard.classList.remove("up")
        this.topCard.classList.add("right")
      } else if (propX < -0.2) {
        this.topCard.classList.remove("right")
        this.topCard.classList.remove("up")
        this.topCard.classList.add("left")
      } else if (propY < -0.2) {
        this.topCard.classList.remove("right")
        this.topCard.classList.remove("left")
        this.topCard.classList.add("up")
      } else {
        this.topCard.classList.remove("right")
        this.topCard.classList.remove("left")
        this.topCard.classList.remove("up")
      }


      if (e.isFinal) {

        this.isPanning = false

        let successful = false

        // set back transition properties
        this.topCard.style.transition = 'transform 200ms ease-out'
        if (this.nextCard) this.nextCard.style.transition = 'transform 100ms linear'



        // check threshold
        if (propX > 0.20) {

          axios.post('https://dmea.deluxxe.ch/api/like/'+this.topCard.id)

          successful = true
          // get right border position
          posX = this.board.clientWidth

        } else if (propX < -0.20) {
          axios.delete('https://dmea.deluxxe.ch/api/dislike/'+this.topCard.id)

          successful = true
          // get left border position
          posX = -(this.board.clientWidth + this.topCard.clientWidth)

        } else if (propY < -0.20) {
          axios.post('https://dmea.deluxxe.ch/api/superlike/'+this.topCard.id)

          successful = true
          // get top border position
          posY = -(this.board.clientHeight + this.topCard.clientHeight)

        } else if (propY > 0.20) {
          this.topCard.classList.remove("full")
        }

        if (successful) {

          // throw card in the chosen direction
          this.topCard.style.transform =
                  'translateX(' + posX + 'px) translateY(' + posY + 'px) rotate(' + deg + 'deg)'

          // wait transition end
          setTimeout(() => {
            // remove swiped card
            this.board.removeChild(this.topCard)
            // add new card
            this.push()
            // handle gestures on new top card
            this.handle()
          }, 200)

        } else {

          // reset cards position
          this.topCard.style.transform =
                  'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(1)'
          if (this.nextCard) this.nextCard.style.transform =
                  'translateX(-50%) translateY(-50%) rotate(0deg) rotateY(0deg) scale(0.95)'

        }

      }

    }

    push() {

      let card = document.createElement('div')

      card.classList.add('card')
      card.id = cards[this.i].id

      card.innerHTML = toHTML(cards[this.i])
      this.i++;

      if (this.board.firstChild) {
        this.board.insertBefore(card, this.board.firstChild)
      } else {
        this.board.append(card)
      }

    }

  }

  let allcards = []
  let cards = [];

  function toHTML(card) {
    let weekday = [
      'Sonntag',
      'Montag',
      'Dienstag',
      'Mittwoch',
      'Donnerstag',
      'Freitag',
      'Samstag'
    ]

    let startTime = moment.utc(card.startTime)
    let endTime = moment.utc(card.endTime)
    console.log(card);
    return "<h2>" + card.name + "</h2>" +
            "<i class=\"far fa-calendar-day\"></i> " + weekday[startTime.day()] + " " + startTime.date() + ". April <br>" +
            "<i class=\"far fa-clock\"></i> " + startTime.format("HH") + ":" + endTime.format("mm") + " - " + endTime.format("HH") + ":" + endTime.format("mm") + "" +
            "<div class='description'>" + card.description + "</div>" +
            "<b><i class=\"fas fa-map-marker\"></i> Standort:</b> " + card.place +
            "  <p><a href='" + card.externalLink + "'><i class=\"far fa-external-link\"></i> Mehr Informationen</a></p>";
  }

  axios.get('https://dmea.deluxxe.ch/api/list')
          .then(function (response) {
            allcards = response.data;
            cards = allcards.filter(function (element) {
              return element.status === 'unrated'
            });
            let board = document.querySelector('#board')

            let carousel = new Carousel(board)
          })
          .catch(function (error) {
            // handle error
            console.log(error);
          })
          .then(function () {
            // always executed
          });


</script>
